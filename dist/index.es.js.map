{"version":3,"file":"index.es.js","sources":["../src/utils/validators.js","../src/utils/textUtils.js","../src/core/canvasTextParagraphs.js","../src/index.js"],"sourcesContent":["export function validateNumber(input, errorMessage) {\n  if (typeof input !== 'number') {\n    throw new Error(errorMessage)\n  }\n}\nexport function validateString(input, errorMessage) {\n  if (typeof input !== 'string') {\n    throw new Error(errorMessage)\n  }\n}\n\nexport function isCanvasContext(ctx) {\n  if (!(ctx instanceof CanvasRenderingContext2D)) {\n    throw new Error('Invalid ctx')\n  }\n}\n\nexport function checkArrayValue(arr, inputValue, errorMessage) {\n  if (!arr.includes(inputValue)) {\n    throw new Error(errorMessage)\n  }\n}","export function wrapText(text, ctx, xStart, maxWidth, indentType, indentWidth) {\n  const words = text.split(' ')\n  let lines = [],\n    currentLine = '';\n\n  for (const word of words) {\n    let testLine = currentLine + word + ' ',\n      testWidth = ctx.measureText(testLine).width;\n    if (indentType === 'firstLine' && lines.length === 0) {\n      testWidth += indentWidth\n    } else if (indentType === 'hanging' && lines.length !== 0) {\n      testWidth += indentWidth\n    }\n    testWidth += xStart\n\n    if (testWidth > maxWidth && currentLine.length > 0) {\n      lines.push(currentLine.trim());\n      currentLine = word + ' '\n    } else {\n      currentLine = testLine\n    }\n  }\n  //latest line\n  lines.push(currentLine.trim())\n\n  return lines;\n}\n\nexport function drawLine(lineObj, ctx, xStart, maxHeight, maxWidth, heightSpace) {\n  const metrics = ctx.measureText(lineObj.text);\n  const align = lineObj.align\n  let x = xStart,\n    yText = lineObj.y,\n    xText = lineObj.x\n  if (yText + heightSpace <= maxHeight) {\n    if (align === 'left') {\n      x += xText\n    } else if (align === 'center') {\n      const widthSpace = (maxWidth - x - metrics.width) / 2\n      if (xText > widthSpace) {\n        x += xText;\n      } else {\n        x += widthSpace\n      }\n    } else if (align === 'right') {\n      const widthSpace = maxWidth - metrics.width\n      if (widthSpace > x + xText) {\n        x = widthSpace;\n      } else {\n        x += xText\n      }\n    } else if (align === 'justify') {\n      const words = lineObj.text.split(' ')\n      const spaceWidth = ((maxWidth - x - xText) - metrics.width + ctx.measureText(' ').width * (words.length - 1)) / (words.length - 1)\n      let currentX = x + xText\n\n      words.forEach((word, index) => {\n        ctx.fillText(word, currentX, yText + heightSpace)\n        if (index < words.length - 1) {\n          currentX += ctx.measureText(word).width + spaceWidth;\n        }\n      });\n      // out from function\n      return;\n    }\n    // Draw text for left, center, and right alignment\n    ctx.fillText(lineObj.text, x, yText + heightSpace);\n  }\n\n}","import { validateNumber, checkArrayValue, isCanvasContext, validateString } from \"../utils/validators\";\n\nimport { wrapText, drawLine } from \"../utils/textUtils\";\n\n/**\n * Draws paragraphs of text on a canvas with various formatting options.\n * \n * @param {string} text - The text to be drawn on the canvas. Must be a valid string.\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context. Must be an instance of CanvasRenderingContext2D.\n * @param {object} [options={}] - Optional configuration object for formatting the text.\n * @param {number|string} [options.height='auto'] - The height of the text area. Can be a number or 'auto'.\n * @param {number|string} [options.width='auto'] - The width of the text area. Can be a number or 'auto'.\n * @param {string} [options.baseLine='top'] - The baseline alignment of the text. Valid values are 'top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'.\n * @param {number} [options.xStart=0] - The x-coordinate where the text starts.\n * @param {number} [options.yStart=0] - The y-coordinate where the text starts.\n * @param {string} [options.align='left'] - The horizontal alignment of the text. Valid values are 'left', 'center', 'right', 'justify'.\n * @param {string} [options.verticalAlign='top'] - The vertical alignment of the text. Valid values are 'top', 'middle', 'bottom'.\n * @param {number} [options.spaceBeforeParagraph=0] - The space before each paragraph in pixels.\n * @param {number} [options.spaceAfterParagraph=0] - The space after each paragraph in pixels.\n * @param {number|string} [options.lineSpacing='auto'] - The spacing between lines of text. Can be a number or 'auto'.\n * @param {object} [options.indent={}] - Configuration for text indentation.\n * @param {string} [options.indent.type='none'] - The type of indentation. Valid values are 'none', 'firstLine', 'hanging'.\n * @param {number} [options.indent.by=0] - The number of spaces to indent.\n * \n * @example\n * const canvas = document.getElementById('myCanvas');\n * const ctx = canvas.getContext('2d');\n * const text = \"This is a sample text to draw on the canvas.\";\n * const options = {\n *   width: 400,\n *   height: 300,\n *   baseLine: 'alphabetic',\n *   xStart: 20,\n *   yStart: 20,\n *   align: 'justify',\n *   verticalAlign: 'middle',\n *   spaceBeforeParagraph: 15,\n *   spaceAfterParagraph: 15,\n *   lineSpacing: 1.5,\n *   indent: {\n *     type: 'firstLine',\n *     by: 4\n *   }\n * };\n * canvasTextParagraphs(text, ctx, options);\n */\n\nexport default function canvasTextParagraphs(text, ctx, options = {}) {\n  validateString(text, 'Invalid text')\n  isCanvasContext(ctx)\n\n  const defaultOptions = {\n    height: 'auto',\n    width: 'auto',\n    baseLine: 'top',\n    xStart: 0,\n    yStart: 0,\n    align: 'left',\n    verticalAlign: 'top',\n    spaceBeforeParagraph: 0,\n    spaceAfterParagraph: 0,\n    lineSpacing: 'auto',\n    indent: {\n      type: 'none',\n      by: 0\n    },\n  }\n  const mergedOptions = { ...defaultOptions, ...options }\n  const validBaseLine = [\n    \"top\",\n    \"hanging\",\n    \"middle\",\n    \"alphabetic\",\n    \"ideographic\",\n    \"bottom\",\n  ],\n    validAlign = ['left', 'center', 'right', 'justify'],\n    validIndentType = ['none', 'firstLine', 'hanging'],\n    validVerticalAlign = ['top', 'middle', 'bottom']\n\n  checkArrayValue(validBaseLine, mergedOptions.baseLine, 'Invalid Baseline')\n  checkArrayValue(validAlign, mergedOptions.align, 'Invalid Align')\n  checkArrayValue(validIndentType, mergedOptions.indent.type, 'Invalid indent.type')\n  checkArrayValue(validVerticalAlign, mergedOptions.verticalAlign, 'Invalid verticalAlign')\n\n  validateNumber(mergedOptions.spaceBeforeParagraph, 'Invalid spaceBeforeParagraph')\n  validateNumber(mergedOptions.spaceAfterParagraph, 'Invalid spaceAfterParagraph')\n  validateNumber(mergedOptions.xStart, 'Invalid xStart')\n  validateNumber(mergedOptions.yStart, 'Invalid yStart')\n\n  try {\n    validateNumber(mergedOptions.width, 'Invalid width')\n  } catch (error) {\n    if (mergedOptions.width !== 'auto') {\n      throw new Error('Invalid width')\n    }\n  }\n\n  try {\n    validateNumber(mergedOptions.height, 'Invalid height')\n  } catch (error) {\n    if (mergedOptions.height !== 'auto') {\n      throw new Error('Invalid height')\n    }\n  }\n  validateNumber(mergedOptions.indent.by, 'Invalid indent.by')\n\n  try {\n    validateNumber(mergedOptions.lineSpacing, 'Invalid lineSpacing')\n  } catch (error) {\n    if (mergedOptions.lineSpacing !== 'auto') {\n      throw new Error('Invalid lineSpacing')\n    }\n  }\n\n  let width = ctx.canvas.width,\n    height = ctx.canvas.height\n  if (mergedOptions.width !== 'auto') {\n    width = mergedOptions.width\n  }\n  if (mergedOptions.height !== 'auto') {\n    height = mergedOptions.height\n  }\n\n  const paragraphs = text.split('\\n')\n\n  // ctx processing\n  ctx.textBaseline = mergedOptions.baseLine\n\n  const alphSample = \"aAgG\"\n  const sampleMetrics = ctx.measureText(alphSample)\n  let lineHeight = (sampleMetrics.actualBoundingBoxAscent + sampleMetrics.actualBoundingBoxDescent) + 1\n  if (mergedOptions.lineSpacing !== 'auto') {\n    lineHeight *= mergedOptions.lineSpacing\n  }\n\n  const dataParagraphs = {\n    paragraphs: [],\n    xStart: mergedOptions.xStart,\n    yStart: mergedOptions.yStart,\n    width,\n    height,\n    vAlign: mergedOptions.verticalAlign,\n  }\n\n  let y = dataParagraphs.yStart ?? 0\n  let indentWidth = 0;\n\n  switch (mergedOptions.indent.type) {\n    case 'hanging':\n      indentWidth = ctx.measureText(' '.repeat(mergedOptions.indent.by)).width;\n      break;\n    case 'firstLine':\n      indentWidth = ctx.measureText(' '.repeat(mergedOptions.indent.by)).width;\n      break;\n    case 'none':\n    default:\n      indentWidth = 0;\n      break;\n  }\n\n  for (let i = 0; i < paragraphs.length; i++) {\n    const paragraph = paragraphs[i]\n    const paragraphTrimmed = paragraph.trim()\n    const data = {\n      lines: [],\n      yStart: 0,\n      yEnd: 0,\n    }\n    y += mergedOptions.spaceBeforeParagraph\n    data.yStart = y\n    const lines = wrapText(paragraphTrimmed, ctx, dataParagraphs.xStart, dataParagraphs.width, mergedOptions.indent.type, indentWidth)\n\n    for (let j = 0; j < lines.length; j++) {\n      const line = lines[j];\n      let lineX = 0\n      if (j > 0 && mergedOptions.indent.type === 'hanging') {\n        lineX += indentWidth;\n      } else if (j === 0 && mergedOptions.indent.type === 'firstLine') {\n        lineX += indentWidth\n      }\n      let align = mergedOptions.align\n      if (j === lines.length - 1 && align === 'justify') {\n        align = 'left'\n      }\n\n      data.lines.push({\n        text: line,\n        x: lineX,\n        y,\n        align,\n      })\n      y += lineHeight\n    }\n\n    y += mergedOptions.spaceAfterParagraph\n    data.yEnd = y\n    dataParagraphs.paragraphs.push(data)\n  }\n  //latest yEnd of lates paragraph\n  let paragraphsHeight = dataParagraphs.paragraphs[dataParagraphs.paragraphs.length - 1].yEnd,\n    heightSpace = 0\n\n  if (mergedOptions.verticalAlign === 'middle') {\n    heightSpace = (dataParagraphs.height - paragraphsHeight) / 2\n  } else if (mergedOptions.verticalAlign === 'bottom') {\n    heightSpace = (dataParagraphs.height - paragraphsHeight)\n  }\n\n  // Draw\n  for (const paragraph of dataParagraphs.paragraphs) {\n    for (const line of paragraph.lines) {\n      drawLine(line, ctx, dataParagraphs.xStart, dataParagraphs.height, dataParagraphs.width, heightSpace)\n    }\n  }\n\n}","/**\n * @license\n * MIT License\n * \n * Copyright (c) 2024 Sukron Ch<sukron@sch39.dev>\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport canvasTextParagraphs from \"./core/canvasTextParagraphs\";\n\nexport default canvasTextParagraphs"],"names":["validateNumber","input","errorMessage","validateString","isCanvasContext","ctx","checkArrayValue","arr","inputValue","wrapText","text","xStart","maxWidth","indentType","indentWidth","words","lines","currentLine","word","testLine","testWidth","drawLine","lineObj","maxHeight","heightSpace","metrics","align","x","yText","xText","widthSpace","spaceWidth","currentX","index","canvasTextParagraphs","options","mergedOptions","validBaseLine","validAlign","validIndentType","validVerticalAlign","width","height","paragraphs","sampleMetrics","lineHeight","dataParagraphs","y","i","paragraphTrimmed","data","j","line","lineX","paragraphsHeight","paragraph"],"mappings":"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"}